import random
import os
#clase y jugador 
class Jugador:
    def __init__(self, nombres, identificacion, edad, usuario, password, rol="jugador"):
        self.nombres = nombres
        self.identificacion = identificacion
        self.edad = edad
        self.usuario = usuario
        self.password = password
        self.rol = rol

    def __str__(self):
        return f"Usuario: {self.usuario} | Nombre: {self.nombres} | Rol: {self.rol}"

    def a_cadena(self):
        """Convierte el objeto Jugador a una cadena para guardar en .txt"""
        return f"{self.nombres},{self.identificacion},{self.edad},{self.usuario},{self.password},{self.rol}\n"
    #co el @classmethod
    def desde_cadena(cls, cadena):
        """Crea un objeto Jugador desde una cadena de .txt"""
        partes = cadena.strip().split(',')
        if len(partes) == 6:
            nombres, identificacion, edad, usuario, password, rol = partes
            jugador = cls(nombres, identificacion, int(edad), usuario, password, rol)
            return jugador
        elif len(partes) == 8: # Para compatibilidad con archivos viejos
            nombres, identificacion, edad, usuario, password, rol, _, _ = partes
            jugador = cls(nombres, identificacion, int(edad), usuario, password, rol)
            return jugador
        return None
#nodos de arbol de habilidades
class NodoHabilidad:
    def __init__(self, nombre_habilidad, tipo_habilidad="generico", valor=0):
        self.nombre = nombre_habilidad
        self.tipo = tipo_habilidad
        self.valor = valor
        self.izquierda = None
        self.derecha = None

     def __str__(self):
        return f"Habilidad: {self.nombre} ({self.tipo}, Valor: {self.valor})"
        
class ArbolBinarioHabilidades:
    def __init__(self):
        self.raiz = None

    def insertar_habilidad(self, nombre, tipo, valor):
        """Inserta una nueva habilidad en el árbol (implementación simple de BST por nombre)."""
        nuevo_nodo = NodoHabilidad(nombre, tipo, valor)
        if self.raiz is None:
            self.raiz = nuevo_nodo
        else:
            self._insertar_recursivo(self.raiz, nuevo_nodo)

    def _insertar_recursivo(self, nodo_actual, nuevo_nodo):
        if nuevo_nodo.nombre.lower() == nodo_actual.nombre.lower():
            return
        elif nuevo_nodo.nombre.lower() < nodo_actual.nombre.lower():
            if nodo_actual.izquierda is None:
                nodo_actual.izquierda = nuevo_nodo
            else:
                self._insertar_recursivo(nodo_actual.izquierda, nuevo_nodo)
        else:
            if nodo_actual.derecha is None:
                nodo_actual.derecha = nuevo_nodo
            else:
                self._insertar_recursivo(nodo_actual.derecha, nuevo_nodo)
def recorrido_inorden(self):
        """Devuelve una lista de nombres de habilidades en recorrido inorden (Izquierda, Raíz, Derecha)."""
        habilidades = []
        self._inorden_recursivo(self.raiz, habilidades)
        return habilidades

    def _inorden_recursivo(self, nodo, habilidades):
        if nodo:
            self._inorden_recursivo(nodo.izquierda, habilidades)
            habilidades.append(nodo.nombre)
            self._inorden_recursivo(nodo.derecha, habilidades)

    def obtener_habilidades_planas(self):
        """Devuelve todas las habilidades del árbol como una lista de tuplas (nombre, tipo, valor)."""
        habilidades_planas = []
        self._inorden_habilidades_con_tipo_recursivo(self.raiz, habilidades_planas)
        return habilidades_planas

    def _inorden_habilidades_con_tipo_recursivo(self, nodo, habilidades_planas):
        if nodo:
            self._inorden_habilidades_con_tipo_recursivo(nodo.izquierda, habilidades_planas)
            habilidades_planas.append((nodo.nombre, nodo.tipo, nodo.valor))
            self._inorden_habilidades_con_tipo_recursivo(nodo.derecha, habilidades_planas)

    def obtener_habilidades_por_valor(self):
        """Devuelve todas las habilidades del árbol como una lista de tuplas (nombre, tipo, valor), ordenadas por valor descendente."""
        habilidades_planas = self.obtener_habilidades_planas()
        return sorted(habilidades_planas, key=lambda x: x[2], reverse=True)

    @classmethod
    def desde_habilidades_planas(cls, lista_habilidades_info):
        """Crea un nuevo árbol e inserta habilidades desde una lista de (nombre, tipo, valor)."""
        nuevo_arbol = cls()
        for item in lista_habilidades_info:
            if len(item) == 3:
                nombre, tipo, valor = item
                nuevo_arbol.insertar_habilidad(nombre, tipo, int(valor))
        return nuevo_arbol

    def buscar_habilidad(self, nombre):
        """Busca una habilidad por nombre en el árbol. Retorna el NodoHabilidad si lo encuentra, None en caso contrario."""
        return self._buscar_recursivo(self.raiz, nombre)

    def _buscar_recursivo(self, nodo, nombre_buscar):
        if nodo is None or nodo.nombre.lower() == nombre_buscar.lower():
            return nodo
        if nombre_buscar.lower() < nodo.nombre.lower():
            return self._buscar_recursivo(nodo.izquierda, nombre_buscar)
        else:
            return self._buscar_recursivo(nodo.derecha, nombre_buscar)
    def eliminar_habilidad(self, nombre):
        """Elimina una habilidad por su nombre del árbol. Retorna True si se eliminó, False en caso contrario."""
        if not self.buscar_habilidad(nombre):
            return False
        self.raiz = self._eliminar_recursivo(self.raiz, nombre)
        return True

    def _eliminar_recursivo(self, nodo_actual, nombre_a_eliminar):
        if nodo_actual is None:
            return nodo_actual

        if nombre_a_eliminar.lower() < nodo_actual.nombre.lower():
            nodo_actual.izquierda = self._eliminar_recursivo(nodo_actual.izquierda, nombre_a_eliminar)
        elif nombre_a_eliminar.lower() > nodo_actual.nombre.lower():
            nodo_actual.derecha = self._eliminar_recursivo(nodo_actual.derecha, nombre_a_eliminar)
        else: # Nodo encontrado
            if nodo_actual.izquierda is None:
                return nodo_actual.derecha
            elif nodo_actual.derecha is None:
                return nodo_actual.izquierda

            temp = self._encontrar_min_valor_nodo(nodo_actual.derecha)
            nodo_actual.nombre = temp.nombre
            nodo_actual.tipo = temp.tipo
            nodo_actual.valor = temp.valor
            nodo_actual.derecha = self._eliminar_recursivo(nodo_actual.derecha, temp.nombre)
        return nodo_actual

    def _encontrar_min_valor_nodo(self, nodo):
        actual = nodo
        while actual.izquierda is not None:
            actual = actual.izquierda
        return actual
#se usara esta clase pra ninjas
class Ninja:
    def __init__(self, nombre, fuerza, agilidad, resistencia, estilo):
        self.nombre = nombre
        self.fuerza = fuerza
        self.agilidad = agilidad
        self.resistencia = resistencia
        self.estilo = estilo
        self.puntos_victoria = 0.0
        self.habilidades = ArbolBinarioHabilidades()
        self.vida_actual = 500 # ¡VIDA VUELVE A 500 HP!

    def __str__(self):
        return f"Ninja: {self.nombre} | Fuerza: {self.fuerza} | Agilidad: {self.agilidad} | Resistencia: {self.resistencia} | Estilo: {self.estilo} | PV: {self.puntos_victoria:.1f}"

    def a_cadena(self):
        """Convierte el objeto Ninja a una cadena para guardar en .txt, incluyendo habilidades."""
        habilidades_planas = self.habilidades.obtener_habilidades_planas()
        habilidades_str = ";".join([f"{n}|{t}|{v}" for n, t, v in habilidades_planas])
        return (f"{self.nombre},{self.fuerza},{self.agilidad},{self.resistencia},"
                f"{self.estilo},{self.puntos_victoria},{habilidades_str}\n")

