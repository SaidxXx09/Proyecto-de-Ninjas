import random
import os
#clase y jugador 
class Jugador:
    def __init__(self, nombres, identificacion, edad, usuario, password, rol="jugador"):
        self.nombres = nombres
        self.identificacion = identificacion
        self.edad = edad
        self.usuario = usuario
        self.password = password
        self.rol = rol

    def __str__(self):
        return f"Usuario: {self.usuario} | Nombre: {self.nombres} | Rol: {self.rol}"

    def a_cadena(self):
        """Convierte el objeto Jugador a una cadena para guardar en .txt"""
        return f"{self.nombres},{self.identificacion},{self.edad},{self.usuario},{self.password},{self.rol}\n"
    #co el @classmethod
    def desde_cadena(cls, cadena):
        """Crea un objeto Jugador desde una cadena de .txt"""
        partes = cadena.strip().split(',')
        if len(partes) == 6:
            nombres, identificacion, edad, usuario, password, rol = partes
            jugador = cls(nombres, identificacion, int(edad), usuario, password, rol)
            return jugador
        elif len(partes) == 8: # Para compatibilidad con archivos viejos
            nombres, identificacion, edad, usuario, password, rol, _, _ = partes
            jugador = cls(nombres, identificacion, int(edad), usuario, password, rol)
            return jugador
        return None
#nodos de arbol de habilidades
class NodoHabilidad:
    def __init__(self, nombre_habilidad, tipo_habilidad="generico", valor=0):
        self.nombre = nombre_habilidad
        self.tipo = tipo_habilidad
        self.valor = valor
        self.izquierda = None
        self.derecha = None

     def __str__(self):
        return f"Habilidad: {self.nombre} ({self.tipo}, Valor: {self.valor})"
        
class ArbolBinarioHabilidades:
    def __init__(self):
        self.raiz = None

    def insertar_habilidad(self, nombre, tipo, valor):
        """Inserta una nueva habilidad en el árbol (implementación simple de BST por nombre)."""
        nuevo_nodo = NodoHabilidad(nombre, tipo, valor)
        if self.raiz is None:
            self.raiz = nuevo_nodo
        else:
            self._insertar_recursivo(self.raiz, nuevo_nodo)

    def _insertar_recursivo(self, nodo_actual, nuevo_nodo):
        if nuevo_nodo.nombre.lower() == nodo_actual.nombre.lower():
            return
        elif nuevo_nodo.nombre.lower() < nodo_actual.nombre.lower():
            if nodo_actual.izquierda is None:
                nodo_actual.izquierda = nuevo_nodo
            else:
                self._insertar_recursivo(nodo_actual.izquierda, nuevo_nodo)
        else:
            if nodo_actual.derecha is None:
                nodo_actual.derecha = nuevo_nodo
            else:
                self._insertar_recursivo(nodo_actual.derecha, nuevo_nodo)
def recorrido_inorden(self):
        """Devuelve una lista de nombres de habilidades en recorrido inorden (Izquierda, Raíz, Derecha)."""
        habilidades = []
        self._inorden_recursivo(self.raiz, habilidades)
        return habilidades

    def _inorden_recursivo(self, nodo, habilidades):
        if nodo:
            self._inorden_recursivo(nodo.izquierda, habilidades)
            habilidades.append(nodo.nombre)
            self._inorden_recursivo(nodo.derecha, habilidades)

    def obtener_habilidades_planas(self):
        """Devuelve todas las habilidades del árbol como una lista de tuplas (nombre, tipo, valor)."""
        habilidades_planas = []
        self._inorden_habilidades_con_tipo_recursivo(self.raiz, habilidades_planas)
        return habilidades_planas

    def _inorden_habilidades_con_tipo_recursivo(self, nodo, habilidades_planas):
        if nodo:
            self._inorden_habilidades_con_tipo_recursivo(nodo.izquierda, habilidades_planas)
            habilidades_planas.append((nodo.nombre, nodo.tipo, nodo.valor))
            self._inorden_habilidades_con_tipo_recursivo(nodo.derecha, habilidades_planas)

    def obtener_habilidades_por_valor(self):
        """Devuelve todas las habilidades del árbol como una lista de tuplas (nombre, tipo, valor), ordenadas por valor descendente."""
        habilidades_planas = self.obtener_habilidades_planas()
        return sorted(habilidades_planas, key=lambda x: x[2], reverse=True)

    @classmethod
    def desde_habilidades_planas(cls, lista_habilidades_info):
        """Crea un nuevo árbol e inserta habilidades desde una lista de (nombre, tipo, valor)."""
        nuevo_arbol = cls()
        for item in lista_habilidades_info:
            if len(item) == 3:
                nombre, tipo, valor = item
                nuevo_arbol.insertar_habilidad(nombre, tipo, int(valor))
        return nuevo_arbol

    def buscar_habilidad(self, nombre):
        """Busca una habilidad por nombre en el árbol. Retorna el NodoHabilidad si lo encuentra, None en caso contrario."""
        return self._buscar_recursivo(self.raiz, nombre)

    def _buscar_recursivo(self, nodo, nombre_buscar):
        if nodo is None or nodo.nombre.lower() == nombre_buscar.lower():
            return nodo
        if nombre_buscar.lower() < nodo.nombre.lower():
            return self._buscar_recursivo(nodo.izquierda, nombre_buscar)
        else:
            return self._buscar_recursivo(nodo.derecha, nombre_buscar)
    def eliminar_habilidad(self, nombre):
        """Elimina una habilidad por su nombre del árbol. Retorna True si se eliminó, False en caso contrario."""
        if not self.buscar_habilidad(nombre):
            return False
        self.raiz = self._eliminar_recursivo(self.raiz, nombre)
        return True

    def _eliminar_recursivo(self, nodo_actual, nombre_a_eliminar):
        if nodo_actual is None:
            return nodo_actual

        if nombre_a_eliminar.lower() < nodo_actual.nombre.lower():
            nodo_actual.izquierda = self._eliminar_recursivo(nodo_actual.izquierda, nombre_a_eliminar)
        elif nombre_a_eliminar.lower() > nodo_actual.nombre.lower():
            nodo_actual.derecha = self._eliminar_recursivo(nodo_actual.derecha, nombre_a_eliminar)
        else: # Nodo encontrado
            if nodo_actual.izquierda is None:
                return nodo_actual.derecha
            elif nodo_actual.derecha is None:
                return nodo_actual.izquierda

            temp = self._encontrar_min_valor_nodo(nodo_actual.derecha)
            nodo_actual.nombre = temp.nombre
            nodo_actual.tipo = temp.tipo
            nodo_actual.valor = temp.valor
            nodo_actual.derecha = self._eliminar_recursivo(nodo_actual.derecha, temp.nombre)
        return nodo_actual

    def _encontrar_min_valor_nodo(self, nodo):
        actual = nodo
        while actual.izquierda is not None:
            actual = actual.izquierda
        return actual
#se usara esta clase pra ninjas
class Ninja:
    def __init__(self, nombre, fuerza, agilidad, resistencia, estilo):
        self.nombre = nombre
        self.fuerza = fuerza
        self.agilidad = agilidad
        self.resistencia = resistencia
        self.estilo = estilo
        self.puntos_victoria = 0.0
        self.habilidades = ArbolBinarioHabilidades()
        self.vida_actual = 500 # ¡VIDA VUELVE A 500 HP!

    def __str__(self):
        return f"Ninja: {self.nombre} | Fuerza: {self.fuerza} | Agilidad: {self.agilidad} | Resistencia: {self.resistencia} | Estilo: {self.estilo} | PV: {self.puntos_victoria:.1f}"

    def a_cadena(self):
        """Convierte el objeto Ninja a una cadena para guardar en .txt, incluyendo habilidades."""
        habilidades_planas = self.habilidades.obtener_habilidades_planas()
        habilidades_str = ";".join([f"{n}|{t}|{v}" for n, t, v in habilidades_planas])
        return (f"{self.nombre},{self.fuerza},{self.agilidad},{self.resistencia},"
                f"{self.estilo},{self.puntos_victoria},{habilidades_str}\n")
    @classmethod
    def desde_cadena(cls, cadena):
        """Crea un objeto Ninja desde una cadena de .txt, reconstruyendo el árbol de habilidades."""
        partes = cadena.strip().split(',')
        if len(partes) == 7:
            nombre, fuerza, agilidad, resistencia, estilo, puntos_victoria_str, habilidades_str = partes
            ninja = cls(nombre, int(fuerza), int(agilidad), int(resistencia), estilo)
            ninja.puntos_victoria = float(puntos_victoria_str)

            if habilidades_str:
                habilidades_cargadas = []
                for habilidad_info in habilidades_str.split(';'):
                    if habilidad_info:
                        h_partes = habilidad_info.split('|')
                        if len(h_partes) == 3:
                            habilidades_cargadas.append((h_partes[0], h_partes[1], int(h_partes[2])))
                ninja.habilidades = ArbolBinarioHabilidades.desde_habilidades_planas(habilidades_cargadas)
            return ninja
        return None
# GESTIÓN DE ARCHIVOS
ARCHIVO_USUARIOS = "usuarios.txt"
ARCHIVO_NINJAS = "ninjas.txt"
ARCHIVO_COMBATES_GLOBAL = "combates_global.txt" # Para historial global de combates

def cargar_usuarios():
    """Carga los usuarios registrados desde usuarios.txt."""
    usuarios = []
    try:
        with open(ARCHIVO_USUARIOS, 'r') as f:
            for linea in f:
                usuario = Jugador.desde_cadena(linea)
                if usuario:
                    usuarios.append(usuario)
    except FileNotFoundError:
        pass # No mostrar advertencia si no existe al inicio
    except Exception as e:
        print(f"Error al cargar usuarios: {e}")
    return usuarios

def guardar_usuarios(usuarios):
    """Guarda la lista de usuarios en usuarios.txt."""
    try:
        with open(ARCHIVO_USUARIOS, 'w') as f:
            for usuario in usuarios:
                f.write(usuario.a_cadena())
    except Exception as e:
        print(f"Error al guardar usuarios: {e}")

def cargar_ninjas():
    """Carga los ninjas desde ninjas.txt."""
    ninjas = []
    try:
        with open(ARCHIVO_NINJAS, 'r') as f:
            for linea in f:
                ninja = Ninja.desde_cadena(linea)
                if ninja:
                    ninjas.append(ninja)
    except FileNotFoundError:
        pass # No mostrar advertencia si no existe al inicio
    except Exception as e:
        print(f"Error al cargar ninjas: {e}")
    return ninjas

def guardar_ninjas(ninjas):
    """Guarda la lista de ninjas en ninjas.txt."""
    try:
        with open(ARCHIVO_NINJAS, 'w') as f:
            for ninja in ninjas:
                f.write(ninja.a_cadena())
    except Exception as e:
        print(f"Error al guardar ninjas: {e}")

def registrar_combate_global(log_combate):
    """Registra un combate en el historial global combates_global.txt."""
    try:
        with open(ARCHIVO_COMBATES_GLOBAL, 'a') as f:
            f.write(f"{log_combate}\n\n")
    except Exception as e:
        print(f"Error al registrar combate global: {e}")

def cargar_historial_global_combates():
    """Carga el historial global de combates desde combates_global.txt."""
    historial = []
    try:
        with open(ARCHIVO_COMBATES_GLOBAL, 'r') as f:
            contenido = f.read()
            combates = [c.strip() for c in contenido.split('\n\n') if c.strip()]
            historial.extend(combates)
    except FileNotFoundError:
        pass
    except Exception as e:
        print(f"Error al cargar historial de combates global: {e}")
    return historial

# listas
global_usuarios = []
global_ninjas = []
usuario_actual = None
ninja_seleccionado_jugador = None # ninja del jugador

#esta funcion es para que se limpie la consola
def limpiar_pantalla():
    """Limpia la consola."""
    os.system('cls' if os.name == 'nt' else 'clear')

def pausar_consola():
    """Pausa la ejecución de la consola hasta que el usuario presione Enter."""
    input("Presiona Enter para continuar...")

def buscar_ninja_por_nombre(nombre_buscar):
    """Busca un ninja en global_ninjas por su nombre (insensible a mayúsculas/minúsculas)."""
    for ninja in global_ninjas:
        if ninja.nombre.lower() == nombre_buscar.lower():
            return ninja
    return None

def registrar_nuevo_jugador():
    """Permite a un nuevo usuario registrarse en el sistema."""
    limpiar_pantalla()
    print("\n--- ¡Únete a la aventura ninja! REGISTRO ---")
    nombres = input("Ingresa tus nombres y apellidos: ").strip()
    identificacion = input("Ingresa tu número de identificación: ").strip()
     while True:
            try:
                edad = int(input("Ingresa tu edad: ").strip())
                break
            except ValueError:
                print("¡Ups! Edad inválida. Por favor, ingresa un número.")
    
        while True:
            usuario_email = input("Ingresa tu correo electrónico (será tu usuario, ej. nombre.apellido@gmail.com): ").strip().lower()
            if "@" not in usuario_email or "." not in usuario_email:
                print("Formato de correo inválido. Asegúrate de incluir '@' y '.'")
            elif any(u.usuario == usuario_email for u in global_usuarios):
                print("Este correo ya está registrado. Intenta con otro o inicia sesión.")
            else:
                break
